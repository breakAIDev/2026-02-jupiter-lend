//! Targeted vulnerability PoCs for vaults.
//!
//! These tests intentionally exercise edge/error conditions discussed during audit review.

#[cfg(test)]
mod tests {
    use crate::vaults::fixture::{OperateVars, VaultFixture, DEFAULT_ORACLE_PRICE};
    use bytemuck::{bytes_of, from_bytes};
    use fluid_test_framework::prelude::AccountManager;
    use solana_sdk::account::Account;
    use vaults::state::Tick;

    const RAW_DEBT_OFFSET_IN_TICK: usize = 11; // packed Tick: u16 + i32 + u8 + u32

    fn setup_vault_fixture() -> VaultFixture {
        let mut fixture = VaultFixture::new().expect("Failed to create vault fixture");
        fixture.setup().expect("Failed to setup vault fixture");
        fixture
    }

    fn mutate_tick_raw_debt(fixture: &mut VaultFixture, vault_id: u16, tick: i32, new_raw_debt: u64) {
        let tick_address = fixture.get_tick(vault_id, tick);
        let mut account = fixture
            .liquidity
            .vm
            .get_account(&tick_address)
            .expect("Tick account must exist");

        let start = 8;
        let end = start + core::mem::size_of::<Tick>();

        let mut tick_data = *from_bytes::<Tick>(&account.data[start..end]);
        let tick_data_bytes = bytemuck::bytes_of_mut(&mut tick_data);
        tick_data_bytes[RAW_DEBT_OFFSET_IN_TICK..RAW_DEBT_OFFSET_IN_TICK + 8]
            .copy_from_slice(&new_raw_debt.to_le_bytes());

        account.data[start..end].copy_from_slice(bytes_of(&tick_data));

        let updated = Account {
            lamports: account.lamports,
            data: account.data,
            owner: account.owner,
            executable: account.executable,
            rent_epoch: account.rent_epoch,
        };
        fixture
            .liquidity
            .vm
            .set_account(&tick_address, updated)
            .expect("Failed to overwrite tick");
    }

    fn open_borrow_position(
        fixture: &mut VaultFixture,
        vault_id: u16,
        position_id: u32,
        user: &solana_sdk::signature::Keypair,
        collateral_amount: i128,
        debt_amount: i128,
    ) {
        fixture
            .init_position(vault_id, user)
            .expect("Failed to init position");
        fixture
            .set_oracle_price(DEFAULT_ORACLE_PRICE, true)
            .expect("Failed to set oracle price");
        fixture
            .operate_vault(&OperateVars {
                vault_id,
                position_id,
                user,
                position_owner: user,
                collateral_amount,
                debt_amount,
                recipient: user,
            })
            .expect("Failed to open borrow position");
    }

    #[test]
    #[ignore = "Requires mainnet RPC-backed fixture setup"]
    fn test_poc_tick_empty_lock_after_state_drift() {
        let mut fixture = setup_vault_fixture();
        let vault_id = 1u16;
        let position_id = 1u32;
        let alice = fixture.liquidity.alice.insecure_clone();

        open_borrow_position(
            &mut fixture,
            vault_id,
            position_id,
            &alice,
            1_000_000_000,
            100_000_000,
        );

        let position = fixture
            .read_position(vault_id, position_id)
            .expect("Failed to read position");
        mutate_tick_raw_debt(&mut fixture, vault_id, position.tick, 0);

        let result = fixture.operate_vault(&OperateVars {
            vault_id,
            position_id,
            user: &alice,
            position_owner: &alice,
            collateral_amount: 0,
            debt_amount: -10_000,
            recipient: &alice,
        });

        let err = result.expect_err("Operate should fail when tick raw_debt is zero");
        let err_str = format!("{:?}", err);
        assert!(
            err_str.contains("VAULT_TICK_IS_EMPTY") || err_str.contains("VaultTickIsEmpty"),
            "Expected VaultTickIsEmpty, got: {}",
            err_str
        );
    }

    #[test]
    #[ignore = "Requires mainnet RPC-backed fixture setup"]
    fn test_poc_saturating_sub_masks_tick_debt_underflow() {
        let mut fixture = setup_vault_fixture();
        let vault_id = 1u16;
        let position_id = 1u32;
        let alice = fixture.liquidity.alice.insecure_clone();

        open_borrow_position(
            &mut fixture,
            vault_id,
            position_id,
            &alice,
            1_000_000_000,
            100_000_000,
        );

        let position = fixture
            .read_position(vault_id, position_id)
            .expect("Failed to read position");
        let tick_before = fixture
            .read_tick(vault_id, position.tick)
            .expect("Failed to read tick before mutation");
        assert!(tick_before.raw_debt > 1, "Need non-trivial tick debt");

        // Force a desynced state: tick debt is less than user debt.
        mutate_tick_raw_debt(&mut fixture, vault_id, position.tick, 1);

        // This succeeds today due to saturating_sub in operate() and silently normalizes inconsistency.
        fixture
            .operate_vault(&OperateVars {
                vault_id,
                position_id,
                user: &alice,
                position_owner: &alice,
                collateral_amount: 0,
                debt_amount: -50_000_000,
                recipient: &alice,
            })
            .expect("PoC expects operate to succeed instead of invariant-reverting");
    }

    #[test]
    #[ignore = "Requires mainnet RPC-backed fixture setup"]
    fn test_poc_negative_supply_magnifier_decreases_exchange_price() {
        let mut fixture = setup_vault_fixture();
        let vault_id = 1u16;

        let state_before = fixture
            .read_vault_state(vault_id)
            .expect("Failed to read initial state");
        let initial_supply_ex_price = state_before.supply_exchange_price;

        // First call sets config to negative (price update in this call still uses old config).
        fixture
            .update_supply_rate_magnifier(vault_id, -5_000)
            .expect("Failed to set negative supply magnifier");

        // Advance time so magnifier has effect.
        fixture.warp(24 * 60 * 60);

        // Second call updates prices using current negative magnifier.
        fixture
            .update_supply_rate_magnifier(vault_id, -5_000)
            .expect("Failed to apply price update with negative magnifier");

        let state_after = fixture
            .read_vault_state(vault_id)
            .expect("Failed to read final state");

        assert!(
            state_after.supply_exchange_price < initial_supply_ex_price,
            "Expected decreased exchange price with negative magnifier. before={}, after={}",
            initial_supply_ex_price,
            state_after.supply_exchange_price
        );
    }
}
